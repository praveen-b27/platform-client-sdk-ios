// UrlSessionImplementations.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation

class UrlSessionRequestBuilderFactory: RequestBuilderFactory {
    func getBuilder<T>() -> RequestBuilder<T>.Type {
        return UrlSessionRequestBuilder<T>.self
    }
}

open class UrlSessionRequestBuilder<T>: RequestBuilder<T> {
    private let jsonDecoder: JSONDecoder = {
        let jsonDecoder = JSONDecoder()
        jsonDecoder.keyDecodingStrategy = .convertFromSnakeCase

        let formatter = DateFormatter()
        formatter.calendar = Calendar(identifier: .iso8601)
        formatter.locale = Locale(identifier: "en_US_POSIX")
//        formatter.timeZone = TimeZone(abbreviation: "UTC")

        // https://www.hackingwithswift.com/articles/119/codable-cheat-sheet
        jsonDecoder.dateDecodingStrategy = .custom { (jsonDecoder) -> Date in
            let container = try jsonDecoder.singleValueContainer()
            let dateStr = try container.decode(String.self)

            formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXXX"
            if let date = formatter.date(from: dateStr) {
                return date
            }
            formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ssXXXXX"
            if let date = formatter.date(from: dateStr) {
                return date
            }
            throw ApiError.invalidDate
        }

//        jsonDecoder.dateDecodingStrategy = .iso8601

        return jsonDecoder
    }()

    public required init(method: String, url: URLComponents, body: Data?, headers: [String: String] = [:]) {
        super.init(method: method, url: url, body: body, headers: headers)
    }

    open override func execute(_ completion: @escaping (_ response: Response<T>?, _ error: Error?) -> Void) {
        let session = URLSession(configuration: .default)

        var request = URLRequest(url: url.url!)

        // Set headers
        for (key, value) in headers {
            request.setValue(value, forHTTPHeaderField: key)
        }

        // Create completion handler
        let completionHandler = { (data: Data?, response: URLResponse?, error: Error?) in
            // Handle Error
            if let error = error {
                completion(
                    nil,
                    ApiError.generalError(error)
                )
                return
            }

            // Handle Empty Response
            guard let response = response as? HTTPURLResponse else {
                completion(
                    nil,
                    ApiError.emptyResponse
                )
                return
            }

            // Handle Empty Data
            guard let data = data else {
                completion(
                    Response(
                        response: response,
                        body: nil,
                        data: nil
                    ),
                    nil
                )
                return
            }

            // At least it didn't blow up... decode response as string
            let responseString = String(data: data, encoding: String.Encoding.utf8)
            
            // Check for successful status code
            if response.statusCode < 200 || response.statusCode >= 300 {
                completion(
                    nil,
                    ApiError.apiError(statusCode: response.statusCode, errorBody: responseString!, correlationId: response.allHeaderFields["ININ-Correlation-Id"] as? String)
                )
                return
            }

            completion(
                Response(
                    response: response,
                    body: nil,
                    data: data
                ),
                nil
            )
        }

        switch method {
        case "GET":
            request.httpMethod = "GET"
        case "POST":
            request.httpMethod = "POST"
            if let b = self.body {
                request.setValue("application/json", forHTTPHeaderField: "content-type")
                request.setValue("application/json", forHTTPHeaderField: "accept")
                request.httpBody = b
            }
        case "PATCH":
            request.httpMethod = "PATCH"
            if let b = self.body {
                request.setValue("application/json", forHTTPHeaderField: "content-type")
                request.setValue("application/json", forHTTPHeaderField: "accept")
                request.httpBody = b
            }
        case "PUT":
            request.httpMethod = "PUT"
            if let b = self.body {
                request.setValue("application/json", forHTTPHeaderField: "content-type")
                request.setValue("application/json", forHTTPHeaderField: "accept")
                request.httpBody = b
            }
        case "DELETE":
            request.httpMethod = "DELETE"
            if let b = self.body {
                request.setValue("application/json", forHTTPHeaderField: "content-type")
                request.setValue("application/json", forHTTPHeaderField: "accept")
                request.httpBody = b
            }
        default:
            completion(
                nil,
                ApiError.unknownHttpVerb(verb: method)
            )
        }

        // Execute API request
        session.dataTask(with: request, completionHandler: completionHandler).resume()
    }

    open override func decode<T: Decodable>(_ response: Response<T>) throws -> Void {
        do {
            if let data = response.data {
                response.body = try jsonDecoder.decode(T.self, from: data)
            } else {
                throw ApiError.decoderDataError
            }
        } catch {
            throw ApiError.decoderError(error)
        }
    }

    fileprivate func getFileName(fromContentDisposition contentDisposition: String?) -> String? {
        guard let contentDisposition = contentDisposition else {
            return nil
        }

        let items = contentDisposition.components(separatedBy: ";")

        var filename: String?

        for contentItem in items {
            let filenameKey = "filename="
            guard let range = contentItem.range(of: filenameKey) else {
                break
            }

            filename = contentItem
            return filename?
                .replacingCharacters(in: range, with: "")
                .replacingOccurrences(of: "\"", with: "")
                .trimmingCharacters(in: .whitespacesAndNewlines)
        }

        return filename
    }

    fileprivate func getPath(from url: URL) throws -> String {
        guard var path = URLComponents(url: url, resolvingAgainstBaseURL: true)?.path else {
            throw DownloadException.requestMissingPath
        }

        if path.hasPrefix("/") {
            path.remove(at: path.startIndex)
        }

        return path
    }

    fileprivate func getURL(from urlRequest: URLRequest) throws -> URL {
        guard let url = urlRequest.url else {
            throw DownloadException.requestMissingURL
        }

        return url
    }
}

private enum DownloadException: Error {
    case responseDataMissing
    case responseFailed
    case requestMissing
    case requestMissingPath
    case requestMissingURL
}

public enum ApiError: Error {
    case emptyResponse
    case decoderError(Error)
    case decoderDataError
    case unknownHttpVerb(verb: String)
    case generalError(Error)
    case invalidDate
    case apiError(statusCode: Int?, errorBody: String?, correlationId: String?)
}